# 2주차 (~21.08.22)

[TOC]

## 변수와 데이터타입, 배열

### 변수란?

프로그램은 작업을 처리하는 과정에서 필요에 따라 데이터를 메모리에 저장합니다.

이때 변수를 사용하는데, <u>변수</u>는 **값을 저장할 수 있는 메모리의 공간**을 의미합니다.

변수에는 복수 개의 값을 저장할 수 없고, **하나의 값만 저장**할 수 있습니다.

또한 변수에는 다양한 타입의 값을 저장할 수 없고, 하나의 타입에 대한 값만 저장할 수 있습니다.

<br/>

### 변수의 선언

```java
int age;
double value;
int x, y, z, arr[][];
```

변수를 사용하기 위해서는 먼저 변수를 선언해야 합니다.

변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무엇인지를 결정합니다.

같은 타입의 변수는 콤마(,)를 이용해 한꺼번에 선언할 수 있습니다.

<br/>

### 변수 명명 규칙 (Naming Convention)

| 작성 규칙                                                    | 예                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| 첫 글자는 문자이거나 `$`, `_` 이어야 하고 숫자로 시작할 수 없다. | O : price, $price, _companyName<br />X : 1v, @speed ... |
| 영어 대소문자가 구분된다.                                    | `firstname`과 `firstName`은 다른 변수                   |
| 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다. (관례, 카멜케이스) | maxSpeed, firstName, carBodyColor ...                   |
| 문자 수(길이)의 제한은 없다.                                 |                                                         |
| 자바 예약어는 사용할 수 없다.                                | X : private, new, instanceof, transient, package ...    |

개발자는 변수 이름을 보고, 이 변수가 어떤 값을 저장하고 있는지 쉽게 알 수 있도록 의미 있는 변수 이름을 지어주는 것이 좋습니다.

변수 이름의 길이는 프로그램 실행과는 무관하기 때문에 충분히 길어도 상관없습니다.

<br/>

### 변수의 사용

#### 변수값 저장

변수에 값을 저장할 때에는 대입 연산자(=)를 사용합니다.

대입 연산자는 우측의 값을 좌측 변수에 저장한다는 의미를 갖습니다.

<u>변수를 선언하고 처음 값을 저장할 경우</u>, 이러한 값을 **초기값**이라고 합니다.

그리고 <u>변수에 초기값을 주는 행위</u>를 **변수의 초기화**라고 합니다.

<br/>

```java
int score;
score = 90;
```

```java
int score = 90;
```

변수를 먼저 선언하고 초기값을 할당하거나 변수를 선언함과 동시에 초기값을 할당할 수 있습니다.

<br/>

#### 리터럴

**소스 코드 내에서 직접 입력된 값**을 <u>리터럴(literal)</u>이라고 부릅니다.

리터럴 값은 종류에 따라 **정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴**로 구분됩니다.

이 리터럴들은 정해진 표기법대로 작성되어야 합니다.

사실, 리터럴은 상수(constant)와 같은 의미지만, 프로그램에서는 상수를 "값을 한 번 저장하면 변경할 수 없는 변수"로 정의하기 때문에 이와 구분하기 위해 "리터럴" 이라는 용어를 사용합니다.

리터럴들은 변수의 초기값으로 소스 코드에서 많이 나타납니다.

<br/>

**정수 리터럴**

```java
0, 75, -100
```

소수점이 없는 정수 리터럴은 10진수로 간주합니다.

```java
02, -04
```

0으로 시작되는 리터럴은 8진수로 간주합니다.

```java
0x5, 0xA, 0xB3, 0xAC08
```

0x 또는 0X로 시작하고 0~9 숫자나 A, B, C, D, E, F 또는 a, b, c, d, e, f 로 구성된 리터럴은 16진수로 간주합니다.

정수 리터럴을 저장할 수 있는 타입은 **byte, char, short, int, long** 이 있습니다.

<br/>

**실수 리터럴**

```java
0.25, -3.14
```

소수점이 있는 리터럴은 10진수 실수로 간주합니다.

```java
5E7			// 5 x 10^7
0.12E-5	// 0.12 x 10^(-5)
```

대문자 E 또는 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주합니다.

실수 리터럴을 저장할 수 있는 타입은 **float, double** 이 있습니다.

<br/>

**문자 리터럴**

```java
'A', '한', '\t', '\n'
```

작은 따옴표('')로 묶은 텍스틀는 하나의 문자 리터럴로 간주합니다.

| 이스케이프 문자 | 용도                       | 유니코드        |
| --------------- | -------------------------- | --------------- |
| '\t'            | 수평 탭                    | 0x0009          |
| '\n'            | 줄 바꿈                    | 0x000a          |
| '\r'            | 리턴                       | 0x000d          |
| '\ "'           | "(큰 따옴표)               | 0x0022          |
| '\ ''           | '(작은 따옴표)             | 0x0027          |
| '\u16진수'      | 16진수에 해당하는 유니코드 | 0x0000 ~ 0xffff |

역슬래쉬가 붙은 문자 리터럴은 이스케이프(escape) 문자라고도 하는데, 위의 표와 같은 특수한 용도로 사용됩니다.

문자 리터럴을 저장할 수 있는 타입은 **char** 하나뿐입니다.

<br/>

**문자열 리터럴**

```java
"싸피"
"탭 만큼 이동 \t 탭 이후 글"
"한줄 내려 쓰기 \n 두번째 줄"
```

큰따옴표(")로 묶은 텍스트는 문자열 리터럴로 간주합니다.

큰따옴표 안에는 텍스트가 없어도 문자열 리터럴로 간주됩니다.

문자열 리터럴 내부에서도 이스케이프 문자를 사용할 수 있습니다.

문자열 리터럴을 저장할 수 있는 타입은 **String** 하나뿐입니다.

<br/>

**논리 리터럴**

```java
true, false
```

`true` 와 `false` 는 논리 리터럴로 간주합니다.

논리 리터럴을 저장할 수 있는 타입은 **boolean** 하나뿐입니다.

<br/>

#### 변수값 읽기

**변수는 초기화가 되어야 읽을 수 있고, 초기화되지 않는 변수는 읽을 수 없습니다.**

```java
int value;
int result = value + 10;
```

위의 코드는 변수 `value` 가 선언되었지만, 초기화가 되지 않았기 때문에 산술 연산식 `value+10` 에서 컴파일 에러가 발생합니다.

```java
int value = 30;
int result = value + 10;
```

코드를 위와 같이 변경해 `value` 에 초깃값을 설정해준다면 컴파일 에러가 발생하지 않습니다.

<br/>

### 원시(Primitive) 타입

<u>기본(원시) 타입</u>이란 **정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입**을 말합니다.

| 값의 종류 | 기본 타입 | 메모리 사용 크기(byte) | 메모리 사용 크기(bit) | 저장되는 값의 범위                               |
| --------- | --------- | ---------------------- | --------------------- | ------------------------------------------------ |
| 정수      | byte      | 1byte                  | 8bit                  | -128 ~ 127                                       |
| 정수      | short     | 2byte                  | 16bit                 | -32768 ~ 32767                                   |
| 정수      | int       | 4byte                  | 32bit                 | -2147483648 ~ 2147483647<br />( -21억 ~ + 21억)  |
| 정수      | long      | 8byte                  | 64bit                 | -9223372036854775808 ~ 9223372036854775807       |
| 문자      | char      | 2byte                  | 16bit                 | '\u0000' ~ 'uFFFF' (16비트 유니코드 문자 데이터) |
| 실수      | float     | 4byte                  | 32bit                 | 1.4E-45 ~ 3.4028235E38                           |
| 실수      | double    | 8byte                  | 64bit                 | 4.9E-324 ~ 1.7976931348623157E308                |
| 논리      | boolean   | 1byte                  | 8bit                  | true, false                                      |

각 타입에 저장되는 값의 범위를 정확히 외울 필요는 없지만, 메모리 사용 크기 정도는 알고 있는 것이 좋습니다.

정수 타입일 경우 -2^(n-1) ~ 2(n-1)-1 의 값을 저장할 수 있습니다.

여기서 **n이 메모리 사용 크기(bit 수)** 입니다.

`int` 타입의 경우는 4byte(32bit)를 저장할 수 있으므로 32bit 크기의 메모리를 사용합니다.

<u>실수 타입</u>일 경우는 **가수와 지수 부분에 사용되는 bit 크기에 따라서 값의 범위가 결정**됩니다.

<br/>

#### 정수 타입 (byte, short, int, long)

자바는 **기본적으로 정수 연산을 `int` 타입으로 수행**합니다.

그렇기 때문에 저장하려는 값이 정수 리터럴이라면 특별한 이유가 없는 한 `int` 타입 변수에 저장하는 것이 좋습니다.

`byte` 와 `short` 가 `int` 보다 메모리 사용 크기가 작아서 메모리를 절약할 수는 있지만, 값의 범위가 작은 편이라서 연산 시에 범위를 초과하면 잘못된 결과를 얻기 쉽습니다.

<br/>

**byte**

`byte` 타입은 색상 정보 및 파일 또는 이미지 등의 이진(binary) 데이터를 처리할 때 주로 사용됩니다.

<br/>

**short**

`short` 타입은 C언어와의 호환을 위해 사용되며 비교적 자바에서는 잘 사용되지 않습니다.

<br/>

**int**

`int` 타입은 자바에서 정수 연산을 하기 위한 기본 타입입니다.

예를 들어 `byte` 또는 `short` 타입의 변수를 + 연산하면 `int` 타입으로 변환된 후 연산되기 때문에 연산의 결과 역시 `int` 가 됩니다.

이는 **자바에서 정수 연산을 4byte로 처리**하기 때문입니다.

따라서 `byte` 타입이나 `short` 타입으로 변수를 선언한 것과 `int` 타입으로 변수를 선언한 것의 성능 차이는 거의 없습니다.

```java
int number = 10;
int octNumber = 012;
int hexNumber = 0xA;
```

정수값을 직접 코드에서 입력할 경우 8진수, 10진수, 16진수로 표현할 수 있습니다.

위의 코드는 10진수 10을 8진수와 16진수로 표현해 변수에 저장한 것입니다.

변수에 어떤 진수로 입력을 해도 동일한 값이 2진수로 변환되어 저장됩니다.

> 위의 코드는 '00000000 00000000 00000000 00001010' 의 4byte로 저장됩니다.

<br/>

**long**

`long` 타입은 수치가 큰 데이터를 다루는 프로그램에서 필수적으로 사용됩니다.

대표적으로 은행 및 우주와 관련된 프로그램들에 많이 사용됩니다.

`long` 타입의 변수를 초기화할 때는 정수값 뒤에 `l` 또는 `L` 을 붙여 4byte 정수 데이터가 아니라 8byte 정수 데이터임을 컴파일러에게 알릴 수 있습니다.

`int` 타입의 저장 범위를 넘어서는 큰 정수는 반드시 `l` 또는 `L` 을 붙여야 합니다. 그렇지 않으면 컴파일 에러가 발생합니다.

일반적으로 `l` 은 숫자`1` 과 비슷해 `L` 을 사용합니다.

<br/>

#### 실수 타입 (float, double)

실수 타입은 소수점이 있는 실수 데이터를 저장할 수 있는 타입으로, 메모리 사용 크기에 따라 `float` 와 `double` 이 있습니다.

**`float` 와 `double` 의 메모리 사용 크기는 `int` 와 `long` 의 크기와 같지만, 정수 타입과는 다른 저장 방식 덕분에 정수 타입보다 훨씬 더 큰 범위의 값을 저장할 수 있습니다.**

![image](https://user-images.githubusercontent.com/49138331/130349257-32761446-99a4-421c-a671-af8eb2a83df7.png)

실수는 정수와 달리 **부동 소수점 방식으로 저장**됩니다. (위 그림 참고)

![image](https://user-images.githubusercontent.com/49138331/130349390-4d3e7c36-0d8b-4c02-9a05-88ba3717c1c6.png)

`float` 타입과 `double` 타입은 가수와 지수를 저장하기 위해 전체 bit를 나누어서 사용합니다.

위의 그림에서 가수를 표현하는데 있어서 `float` 에 비해 `double` 이 약 두 배의 자릿수가 배정되어 있습니다.

따라서 `float` 보다 `double` 이 더 정밀한 값을 저장할 수 있고, 높은 정밀도를 요구하는 계산에서는 `double` 을 사용하는 것이 유리합니다.

<br/>

자바는 <u>실수 리터럴의 기본 타입을 `double` 로 간주</u>합니다.

```java
double var1 = 3.14;
float var2 = 3.14;	// 컴파일 에러
float var3 = 3.14f;
```

실수 리터럴을 `float` 타입 변수에 저장하기 위해서는 리터럴 뒤에 `f` 또는 `F` 를 붙여야 합니다.

```java
int var6 = 3000000;	// 3000000
double var7 = e36;	// 3000000
float var8 = e36f;	// 3000000
double var9 = 2e-3;	// 0.002
```

만약 정수 리터럴에 10의 지수를 나타내는 `E` 또는 `e` 를 포함하고 있으면 정수 타입 변수에 저장할 수 없고 실수 타입 변수에 저장해야 합니다.

<br/>

#### 논리 타입 (boolean)

`boolean` 타입은 두 가지 상태값을 저장할 필요성이 있을 경우에 사용되며, 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용됩니다.

#### 문자 타입 (char)

<br/>

#### 문자 타입 (char)

**char**

자바는 모든 문자를 <u>유니코드(Unicode)</u>로 처리합니다.

유니코드는 하나의 문자에 대해 하나의 코드값을 부여합니다.

자바는 하나의 유니코드를 저장하기 위해 2byte 크기인 `char` 타입을 제공합니다.

**유니코드는 음수가 없기 때문에 `char` 타입의 변수에 음수 값을 저장할 수 없습니다.**

```java
char c = '';	// 컴파일 에러
char c = ' ';
```

`char` 타입의 변수에 어떤 문자를 대입하지 않고 단순히 초기화를 할 목적으로 다음과 같이 빈 문자를 대입하면 컴파일 에러가 발생합니다.

그렇기 때문에 <u>공백 하나를 포함해서 초기화</u>해야 합니다.

<br/>

### Primitive 타입과 Reference 타입

자바의 데이터 타입에는 크게 기본 타입(Primitive)과 참조 타입(Reference)로 분류됩니다.

<u>기본 타입</u>은 **정수, 실수, 문자, 논리 리터럴을 저장하는 타입**을 말하고 <u>참조 타입</u>은 **객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입**을 말합니다.

<br>

#### 차이점

<u>기본 타입</u>인 `byte, char, short, int, long, float, double, boolean` 을 이용해서 선언된 변수는 **실제 값을 변수 안에 저장**합니다.

하지만 <u>참조 타입</u>인 `배열, 열거, 클래스, 인터페이스` 를 이용해서 선언된 변수는 **변수의 참조값을 갖습니다.**

참조값을 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부릅니다.

또한 **변수는 스택 영역에 생성되고 객체는 힙 영역에 생성**됩니다.

따라서 **기본 타입 변수들은 스택에 실제 값을 같이 저장하고 있고, 참조 타입 변수들은 스택에 객체의 참조값을 저장**하고 있습니다.

<br/>

기본 타입 변수의 ==, != 연산은 변수의 값이 같은지 아닌지를 조사하지만 <u>참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용</u>됩니다.

참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 <u>주소 값을 비교하는 것</u>이 됩니다.

동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이기 때문에 **동일한 객체를 참조하고 있을 경우에만 == 연산이 true**입니다.

일반적으로 **참조 변수의 값을 비교하고 싶으면 `equals` 를 재정의해서 사용**합니다.

<br/>

### 변수의 스코프와 라이프타임

<u>변수의 스코프(영역)</u>은 **변수에 접근할 수 있는 유효 범위/영역**을 뜻합니다.

일반적인 규칙은 변수가 선언된 블록({}) 내에서만 액세스할 수 있다는 것입니다.

<u>변수의 라이프타임</u>은 **메모리에서 변수가 언제까지 살아있는가에 대한 것**을 다룹니다.

<br/>

#### 인스턴스 변수

<u>인스턴스(Instance) 변수</u>는 **클래스 내에서 선언되지만 메소드 및 블록 외부에 선언되는 변수**를 뜻합니다.

인스턴스 변수의 <u>스코프</u>는 **정적(static) 메소드를 제외한 모든 클래스**입니다.

인스턴스 변수의 <u>라이프타임</u>은 클래스의 **객체가 힙에서 GC에 의해 제거되기 전까지** 살아있습니다.

#### 클래스 변수

<u>클래스(Class) 변수</u>는 **클래스 안에서 선언되지만 메소드 및 블록 외부에 선언된 static 변수를 뜻**합니다.

클래스 변수의 <u>스코프</u>는 **클래스 전체**이며, <u>라이프타임</u>은 **프로그램 종료 시**까지 입니다.

#### 지역 변수

<u>지역(Local) 변수</u>는 **인스턴스 변수나 클래스 변수가 아닌 모든 변수를 뜻**합니다.

지역 변수의 <u>스코프</u>는 **변수가 선언된 블록({}) 내부**이며, <u>라이프타임</u>은 **변수가 선언된 블록 내부에서 프로그램이 실행되는 동안**입니다.

<br/>

### 타입 변환, 캐스팅, 타입 프로모션

타입 변환이란 **데이터 타입을 다른 데이터 타입으로 변환하는 것**을 말합니다.

타입 변환에는 <u>자동(묵시적) 타입 변환</u>과 <u>강제(명시적) 타입 변환</u>이 있습니다.

<br/>

#### 자동 타입 변환

<u>자동 타입 변환(Promotion)</u>은 **프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것**을 말합니다.

자동 타입 변환은 **작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생**합니다.

> 큰 크기 타입 = 작은 크기 타입

<br/>

큰 크기 타입과 작은 크기 타입의 구분은 사용하는 메모리의 크기입니다.

> byte `1byte` < short `2byte` < int `4byte` < long `8byte` < float `4byte` < double `8byte`

위의 식은 크기별로 타입을 정리한 결과입니다.

`float` 는 표현할 수 있는 값의 범위가 `int` 와 `long` 보다 크기 때문에 크기가 더 크다고 표현합니다.

<br/>

자동 타입 변환이 발생되면 변환 이전의 값과 변환 이후의 값은 동일합니다.

즉, **변환 이전의 값은 변환 이후에도 손실 없이 그대로 보존**됩니다.

정수 타입이 실수 타입으로 변환하는 것은 무조건 프로모션이 됩니다.

```java
int intValue = 200;
double doubleValue = intValue;	// 200.0
```

실수 타입으로 변환된 이후의 값은 정수값이 아닌 .0이 붙은 실수값이 됩니다.

```java
char charValue = 'A';
int intValue = charValue;		// 65
```

`char` 타입의 경우 `int` 타입으로 자동 변환되면 유니코드 값이 `int` 타입에 저장됩니다.

<br/>

```java
byte byteValue = 65;
char charValue = byteValue;		// 컴파일 에러
char charData = (char)byteValue;		// 강제 타입 변환
```

프로모션에서도 예외가 있습니다.

`char` 는 2byte의 크기를 가지지만, `char` 의 범위는 0 ~ 65535 이므로 음수가 저장될 수 없습니다.

따라서 **음수가 저장될 수 있는 `byte` 타입을 `char` 타입으로 자동 변환시킬 수 없습니다.**

<br/>

#### 강제 타입 변환

큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없습니다.

예시로, 4byte인 `int` 타입을 1byte인 `byte` 타입에 담을 수 없습니다.

하지만 `int` 타입을 4개의 byte로 쪼갠 다음, 끝에 있는 1byte만 `byte` 타입 변수에 저장하는 것은 가능합니다.

이 과정이 **강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개서 저장**하는 <u>강제 타입 변환(Casting)</u> 이라고 합니다.

강제 타입 변환은 캐스팅 연산자 ()를 사용하는데, 괄호 안에 들어가는 타입은 작은 타입, 즉 쪼개는 단위입니다.

> 작은 크기 타입 = (작은 크기 타입) 큰 크기 타입

<br/>

```java
int intValue = 103029770;
byte byteValue = (byte) intValue;		// 강제 타입 변환(캐스팅)
```

![image](https://user-images.githubusercontent.com/49138331/130350177-373f2fb3-9c35-4072-a09c-a6cc483b5f79.png)

끝 1byte만 `byte` 타입 변수에 담게 되므로 원래 `int` 값은 보존되지 않습니다.

하지만 `int` 값이 끝의 1byte로만 표현이 가능하다면 `byte` 타입으로 변환해도 같은 값이 유지될 수 있습니다.

이 경우는 강제 타입 변환이 의미 있게 됩니다.

<br/>

```java
int intValue = 'A';
char charValue = (char) intValue;		// A
```

`int` 타입은 `char` 타입으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 합니다.

`int` 타입에 저장된 값이 유니코드 범위(0~65535)라면 위와 같이 `(char)` 캐스팅 연산자를 사용해 `char` 타입으로 변환할 수 있습니다.

<br/>

```java
double doubleValue = 3.14;
int intValue = (int) doubleValue;	// intValue는 정수 부분인 3만 저장
```

실수 타입(`float` , `double`)은 정수 타입(`byte` , `short` , `int` , `long`)으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 합니다.

이 경우 소수전 이하 부분은 버려지고, 정수 부분만 저장됩니다.

<br/>

```java
if (i<Byte.MIN_VALUE || i>Byte.MAX_VALUE) System.out.println("byte 타입으로 변환할 수 없습니다.")
```

강제 타입 변환에서 <u>주의할 점은 사용자로부터 입력받은 값을 전환할 때 값의 손실이 발생하면 안된다는 것</u>입니다.

강제 타입 변환을 하기 전에 우선 <u>안전하게 값이 보존될 수 있는지 검사</u>하는 것이 좋습니다.

<br/>

#### 연산식에서의 자동 타입 변환

<u>연산</u>은 기본적으로 같은 타입의 피연산자 간에만 수행되기 때문에 **서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행**합니다.

예시로 ` int` 타입 피연산자와 `double` 타입 피연산자를 덧셈 연산하면 먼저 `int` 타입 피연산자가 `double` 타입으로 프로모션되고 연산을 수행합니다. 연산의 결과는 `double` 이 됩니다.

만약 `int` 타입으로 꼭 연산을 해야 한다면 `double` 타입을 `int` 타입으로 강제 변환하고 덧셈 연산을 수행하면 됩니다.

<br/>

### 배열

#### 배열이란?

<u>배열</u>은 같**은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조** 입니다.

배열은 <u>같은 타입의 데이터만 저장</u>할 수 있습니다.

또한 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정됩니다. 만약 다른 타입의 값을 저장하려고 하면 `Type mismatch` 컴파일 오류가 발생합니다.

배열의 또 다른 특징은 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없습니다.

만약 길이를 늘리고 싶다면, 원하는 길이의 새로운 배열을 생성하고 기존 배열 항목을 새 배열로 복사해야 합니다.

<br/>

#### 배열 선언

```java
int[] array;
int array[];
```

위의 두 문장 모두 같은 배열 변수를 선언하는 형태입니다.

대괄호([])는 배열 변수를 선언하는 기호로 사용되는데, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있습니다.

<br/>

**배열 변수는 참조 변수에 속합니다.**

배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역에 배열 객체를 참조하게 됩니다.

참조할 배열 객체가 없다면 배열 변수는 `null` 값으로 초기화될 수 있습니다.

만약 배열 변수가 `null` 값을 가진 상태에서 `변수[인덱스]` 로 값을 읽거나 저장하게 되면 `NullPointerException` 이 발생합니다.

배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 합니다.

<br/>

#### 값 목록으로 배열 생성

```java
String[] names = { "김현지", "김자바", "김지현" };
```

중괄호({})는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴합니다.

배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어집니다.

```java
String[] names;
names = { "김현지", "김자바", "김지현" };	// 오류
names = new String[]{ "김현지", "김자바", "김지현" };
```

값의 목록으로 배열 객체를 생성할 때 주의할 점은 **배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않습니다.**

배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 **`new` 연산자**를 사용해 값 목록을 지정해줘야 합니다.

<br/>

#### new 연산자로 배열 생성

```java
int[] intArray = new int[5];
```

값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 `new` 연산자로 배열 객체를 생성시킬 수 있습니다.

`new` 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화됩니다.

| 분류            | 데이터 타입  | 초기값                      |
| --------------- | ------------ | --------------------------- |
| 기본 타입(정수) | byte[]       | 0                           |
| 기본 타입(정수) | short[]      | 0                           |
| 기본 타입(정수) | int[]        | 0                           |
| 기본 타입(정수) | long[]       | 0                           |
| 기본 타입(문자) | char[]       | '\u0000' , ' ' (whitespace) |
| 기본 타입(논리) | boolean[]    | false                       |
| 기본 타입(실수) | float[]      | 0.0F                        |
| 기본 타입(실수) | double[]     | 0.0                         |
| 참조 타입       | 클래스[]     | null                        |
| 참조 타입       | 인터페이스[] | null                        |

<br/>

#### 다차원 배열

```java
int[][] scores = new int[2][3];
```

값들이 행과 열로서 구성된 배열을 2차원 배열이라고 합니다.

2차원 배열은 쉽게 수학의 행렬을 떠올리면 되는데, 가로 인덱스와 세로 인덱스를 사용합니다.

```java
int[][] scores = new int[2][];
scores[0] = new int[2];	// 0, 0
scores[1] = new int[3];	// 0, 0, 0
```

자바는 **일차원 배열이 연결되는 구조로 다차원 배열을 구현**하기 때문에 수학의 행렬 구조가 아닌 계단식 구조를 가질 수 있습니다.

이런 형태의 배열에서 주의할 점은 정확한 배열의 길이를 알고 인덱스를 사용해야 합니다.

`scores[0][2]` 는 `ArrayIndexOutOfBoundsException` 을 발생시킵니다.

<br/>

#### 객체를 참조하는 배열

기본 타입 배열은 각 항목에 직접 값을 갖고 있지만, <u>참조 타입 배열은 각 항목에 객체의 참조값을 가지고 있습니다.</u>

예시로, `String` 은 클래스 타입이므로 `String[]` 배열은 각 항목에 문자열이 아니라, `String` 객체의 주소를 가지고 있습니다.

즉, `String` 객체를 참조하게 되는 것입니다.

<br/>

### 타입 추론, var

<u>타입 추론</u>은 말 그대로 **개발자가 변수의 타입을 명시적으로 적지 않아도 컴파일러가 알아서 변수의 타입을 추론하는 것**입니다.

타입 추론은 <u>`var` 로 변수를 선</u>언해 사용이 가능하며 **초기화값이 반드시 존재하는 지역 변수로만 선언이 가능**합니다.

```java
public static void main(String[] args) {
  var str = "Hello World";
  
  if (str instanceof String) System.out.println("str 변수의 타입은 String 입니다.")
}
```

위의 코드 블록에서 `str` 변수의 타입을 따로 명시하지 않고 `var` 을 사용해 선언해주었습니다.

그리고 컴파일 시점에 컴파일러가 오른쪽에 있는 초기화값 리터럴로 타입을 추론합니다.

<br/>

**`var` 는 멤버 변수, 또는 메소드의 파라미터, 리턴 타입으로 사용이 불가능**합니다.

또한 **무조건 선언 시에 초기화값이 있어야 합니다.**

`var` 는 키워드가 아닙니다. 어떠한 타입도 아니고, 클래스에서 사용할 수 있는 예약어가 아니라는 뜻입니다.

그래서  `var` 라는  `int` 형 변수를 만들 수도 있습니다.

<br/>

`var` 는 **런타임 오버헤드가 없습니다.**

컴파일 시점에 `var` 에 초기화된 값을 보고 추론해서 바이트 코드에 명시적으로 타입을 추론합니다.

이미 타입이 결정되어있는 상태이기 때문에 타입 추론 변수를 읽을 때마다 다시 타입 추론 연산을 하지 않습니다.

그래서 `var` 로 선언된 변수는 중간에 타입이 절대 변경되지 않습니다.

이것은 `자바스크립트, 코틀린, 스위프트` 와 같이 타입 추론을 하는 언어들과는 다른 형태입니다.

<br/>

#### `var` 사용 주의점

- JAVA 10부터 사용 가능합니다.

- 초기화 없이 사용이 불가능합니다.
- null 값이 들어갈 수 없습니다.
- 로컬 변수에만 선언이 가능합니다.
- 람다에는 명시적인 타입을 지정해야하기 때문에 `var` 사용이 불가능합니다.
- 배열 사용 시 `var` 대신 타입을 명시해줘야 합니다.

<br/>

#### 람다에서의 `var`

```java
Consumer<String> test = s -> System.out.println("s=" + s);
Consumer<String> test = (var s) -> System.out.println("s=" + s);
Consumer<String> test = (@Nonnull var s) -> System.out.println("s=" + s);
```

람다 표현식에서 위와 같이  `var` 사용이 가능합니다.

<u>`s` 만 쓰는 것보다  `var s` 를 사용한다면 앞에 어노테이션을 사용할 수 있다는 장점</u>이 있다고 합니다.